var l=class{_events={};on(e,t){let s=e;this._events[s]||(this._events[s]=[]),this._events[s].push(t)}once(e,t){let s=(...o)=>{this.off(e,s),t(...o)};this.on(e,s)}off(e,t){let s=e;this._events[s]&&(this._events[s]=this._events[s].filter(o=>o!==t))}emit(e,...t){let s=this._events[e];s&&s.length>0&&s.forEach(o=>{o(...t)})}listenerCount(e){return this._events[e]?.length||0}},h=l;var u=class{ws;ackIdCounter;ackCallbacks;handlers=new h;opts;url;connected=!1;_manuallyDisconnected=!1;messageQueue=[];constructor(e,t={}){this.ackIdCounter=1,this.ackCallbacks=new Map,this.opts={logs:!1,reConnect:!0,reConnectInterval:1e3,token:null,autoConnect:!0,...t},this.url=new URL(e,typeof window<"u"?window.location.href.replace("http","ws"):"ws://localhost"),this.opts.token&&this.url.searchParams.set("token",this.opts.token),this.opts.autoConnect&&this.connect()}connect(){this._manuallyDisconnected=!1;let e=Date.now().toString(36)+Math.random().toString(36).substring(2,10);this.url.searchParams.set("id",e),this.opts.connectionData&&this.url.searchParams.set("data",JSON.stringify(this.opts.connectionData)),this.ws=new WebSocket(this.url.href),this.ws.onopen=()=>{this.connected=!0,this.opts.logs&&console.log("[ws] Connected");let t;for(;t=this.messageQueue.shift();)this.ws.send(t);this._handlersEmit("connect")},this.ws.onerror=(...t)=>{this.opts.logs&&console.warn("[ws] Error:",t),this._handlersEmit("error",...t)},this.ws.onmessage=t=>{let s=t?.data?.toString()||t?.toString()||"",o;try{o=JSON.parse(s)}catch{this.opts.logs&&console.warn("[ws] Invalid JSON:",s);return}if("ack"in o){let r=o.ack,c=this.ackCallbacks.get(r);c&&(this.ackCallbacks.delete(r),c(...o.data));return}let{evt:i,data:n,ackI:a}=o;if(!(!i||n&&!Array.isArray(n))){if(Array.isArray(a))for(let r=0;r<a.length;r++){let c=a[r];if(!n[c])break;let p=n[c];n[c]=(...f)=>{this.ws.send(JSON.stringify({ack:p,data:f}))}}this._handlersEmit(i,...n)}},this.ws.onclose=async t=>{if(this.connected=!1,this.opts.logs&&console.log("[ws] Disconnected",t),this._handlersEmit("disconnect",t),this._manuallyDisconnected){this._manuallyDisconnected=!1;return}if(t.code===1006){this.opts.logs&&console.log("[ws] Connection closed by server");let s=new URLSearchParams;s.set("id",e),s.set("path",this.url.pathname);let o=await fetch(this.url.origin+"/gloves-link/status?"+s.toString());if(!o.ok)return console.error("[ws] Status error",o.status);let i=await o.json();if(i.err){this.opts.logs&&console.log("[ws] Status error",i.msg);return}let n=i.status;this.opts.logs&&console.log("[ws] Status",n),n.status===401?this._handlersEmit("connect_unauthorized",n.msg):n.status===403?this._handlersEmit("connect_forbidden",n.msg):n.status===500&&this._handlersEmit("connect_serverError",n.msg);return}this.opts.reConnect&&setTimeout(()=>{this.connect()},this.opts.reConnectInterval)}}on(e,t){this.handlers.on(e,t)}once(e,t){this.handlers.once(e,t)}emit(e,...t){let s=t.map((i,n)=>{if(typeof i=="function")return n}).filter(i=>i!==void 0);for(let i=0;i<s.length;i++){let n=s[i],a=this.ackIdCounter++;this.ackCallbacks.set(a,t[n]),t[n]=a}let o=JSON.stringify({evt:e,data:t||void 0,ackI:s.length?s:void 0});this.connected&&this.ws?.readyState===WebSocket.OPEN?this.ws.send(o):this.messageQueue.push(o)}send(e,...t){return this.emit(e,...t)}disconnect(){this._manuallyDisconnected=!0,this.ws.close()}close(){this.ws.close()}_handlersEmit(e,...t){this.handlers.emit(e,...t),this.handlers.emit("*",e,...t)}};export{u as GLC,u as GlovesLinkClient,u as client,u as default};
//# sourceMappingURL=GlovesLinkClient.js.map
