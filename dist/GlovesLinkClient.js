var h=class{_events={};on(e,t){let s=e;this._events[s]||(this._events[s]=[]),this._events[s].push(t)}once(e,t){let s=(...o)=>{this.off(e,s),t(...o)};this.on(e,s)}off(e,t){let s=e;this._events[s]&&(this._events[s]=this._events[s].filter(o=>o!==t))}_emit(e,...t){let s=this._events[e];s?.length&&s.forEach(o=>o(...t))}emit(e,...t){this._emit(e,...t),this._emit("*",e,...t)}listenerCount(e){return this._events[e]?.length||0}},u=h;var d=class{_ws;_ackIdCounter;_ackCallbacks;_handlers=new u;_manuallyDisconnected=!1;_messageQueue=[];_reconnectAttempts=0;opts;url;connected=!1;constructor(e,t={}){this._ackIdCounter=1,this._ackCallbacks=new Map,this.opts={logs:!1,token:null,autoConnect:!0,statusPath:"/gloves-link/status",reConnect:!0,reConnectInterval:1e3,maxReConnectAttempts:5,reConnectBackoffFactor:2,maxReConnectDelay:15e3,...t},this.url=new URL(e,typeof window<"u"?window.location.href.replace("http","ws"):"ws://localhost"),this.opts.token&&this.url.searchParams.set("token",this.opts.token),this.opts.autoConnect&&this.connect()}connect(){this._manuallyDisconnected=!1;let e=Date.now().toString(36)+Math.random().toString(36).substring(2,10);this.url.searchParams.set("id",e),this.opts.connectionData&&this.url.searchParams.set("data",JSON.stringify(this.opts.connectionData)),this._ws=new WebSocket(this.url.href),this._ws.onopen=()=>{this.connected=!0,this._reconnectAttempts=0,this.opts.logs&&console.log("[ws] Connected");let t;for(;t=this._messageQueue.shift();)this._ws.send(t);this._handlersEmit("connect")},this._ws.onerror=(...t)=>{this.opts.logs&&console.warn("[ws] Error:",t),this._handlersEmit("error",...t)},this._ws.onmessage=t=>{let s=t?.data?.toString()||t?.toString()||"",o;try{o=JSON.parse(s)}catch{this.opts.logs&&console.warn("[ws] Invalid JSON:",s);return}if("ack"in o){let c=o.ack,l=this._ackCallbacks.get(c);l&&(this._ackCallbacks.delete(c),l(...o.data));return}let{evt:a,data:n,ackI:i}=o;if(!(!a||n&&!Array.isArray(n))){if(Array.isArray(i))for(let c=0;c<i.length;c++){let l=i[c];if(!n[l])break;let m=n[l];n[l]=(...p)=>{this._ws.send(JSON.stringify({ack:m,data:p}))}}this._handlersEmit(a,...n)}},this._ws.onclose=async t=>{if(this.connected=!1,this.opts.logs&&console.log("[ws] Disconnected",t),this._handlersEmit("disconnect",t),this._manuallyDisconnected||!this.opts.reConnect)return;if(t.code===1006){this.opts.logs&&console.log("[ws] Connection closed by server");try{if(!await f(this,e))return}catch(n){this.opts.logs&&console.error("[ws] Status error",n)}}if(this._reconnectAttempts++,this._reconnectAttempts>this.opts.maxReConnectAttempts){this.opts.logs&&console.error(`[ws] Max reconnect attempts reached (${this.opts.maxReConnectAttempts})`),this._handlersEmit("reconnect_failed");return}let s=Math.min(this.opts.reConnectInterval*this.opts.reConnectBackoffFactor**(this._reconnectAttempts-1),this.opts.maxReConnectDelay),o=1+Math.random()*.5,a=Math.max(s*o,this.opts.reConnectInterval);this.opts.logs&&console.log(`[ws] Reconnecting in ${a.toFixed(0)}ms (attempt ${this._reconnectAttempts})`),setTimeout(()=>{this.connect()},a)}}on(e,t){this._handlers.on(e,t)}once(e,t){this._handlers.once(e,t)}emit(e,...t){let s=t.map((a,n)=>{if(typeof a=="function")return n}).filter(a=>a!==void 0);for(let a=0;a<s.length;a++){let n=s[a],i=this._ackIdCounter++;this._ackCallbacks.set(i,t[n]),t[n]=i}let o=JSON.stringify({evt:e,data:t||void 0,ackI:s.length?s:void 0});this.connected&&this._ws?.readyState===WebSocket.OPEN?this._ws.send(o):this._messageQueue.push(o)}send(e,...t){return this.emit(e,...t)}disconnect(){this._manuallyDisconnected=!0,this._ws.close()}close(){this._ws.close()}_handlersEmit(e,...t){this._handlers.emit(e,...t)}};async function f(r,e){let t=new URL(r.opts.statusPath,r.url.origin);t.searchParams.set("id",e),t.searchParams.set("path",r.url.pathname);let s=t.toString().replace("ws","http"),o=await fetch(s);if(!o.ok)return console.error("[ws] Status error",o.status),!0;let a=await o.json();if(a.err)return r.opts.logs&&console.log("[ws] Status error",a.msg),!0;let n=a.status;return r.opts.logs&&console.log("[ws] Status",n),n.status===401?(r._handlersEmit("connect_unauthorized",n.msg),!1):n.status===403?(r._handlersEmit("connect_forbidden",n.msg),!1):n.status===500?(r._handlersEmit("connect_serverError",n.msg),!1):!0}export{d as GLC,d as GlovesLinkClient,d as client,d as default};
//# sourceMappingURL=GlovesLinkClient.js.map
