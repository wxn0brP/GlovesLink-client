{
  "version": 3,
  "sources": ["../node_modules/@wxn0brp/event-emitter/dist/index.js", "../src/index.ts"],
  "sourcesContent": ["export class VEE {\n    _events = {};\n    /**\n     * Registers an event listener\n     * @param {K} event - event name\n     * @param {Function} listener - function to be called when event occurs\n     */\n    on(event, listener) {\n        const _event = event;\n        if (!this._events[_event])\n            this._events[_event] = [];\n        this._events[_event].push(listener);\n    }\n    /**\n     * Registers a one-time event listener\n     * @param {K} event - event name\n     * @param {Function} listener - function to be called once\n     */\n    once(event, listener) {\n        const onceListener = (...args) => {\n            this.off(event, onceListener);\n            listener(...args);\n        };\n        this.on(event, onceListener);\n    }\n    /**\n     * Removes an event listener.\n     * @param {K} event - event name\n     * @param {Function} listener - listener to remove\n     */\n    off(event, listener) {\n        const _event = event;\n        if (!this._events[_event])\n            return;\n        this._events[_event] = this._events[_event].filter(l => l !== listener);\n    }\n    /**\n     * Emits an event\n     * @param {K} event - event name\n     * @param {...EventArgs<T, K>} args - arguments to be passed to listeners\n     */\n    emit(event, ...args) {\n        const listeners = this._events[event];\n        if (listeners && listeners.length > 0) {\n            listeners.forEach(listener => {\n                listener(...args);\n            });\n        }\n    }\n    /**\n     * Returns the number of listeners for the given event\n     * @param {K} event - event name\n     */\n    listenerCount(event) {\n        return this._events[event]?.length || 0;\n    }\n}\nexport default VEE;\nexport { VEE as EventEmitter };\n", "import VEE, { EventArgs, EventMap, EventName } from \"@wxn0brp/event-emitter\";\n\nexport interface GLC_Opts {\n    logs: boolean;\n    token: string;\n    autoConnect: boolean;\n    connectionData?: Record<string, any>;\n    statusPath: string;\n    reConnect: boolean,\n    reConnectInterval: number,\n    reConnectBackoffFactor: number;\n    maxReConnectAttempts: number;\n    /** Note: without jitter */\n    maxReConnectDelay: number;\n}\n\nexport interface GLC_DataEvent {\n    evt: string;\n    data: any[];\n    ackI?: number[];\n}\n\nexport interface GLC_AckEvent {\n    ack: number;\n    data: any[];\n}\n\nexport type InternalEvents = {\n    connect: (ws: WebSocket) => void;\n    error: (...err: any[]) => void;\n    disconnect: (event: CloseEvent) => void;\n    connect_unauthorized: (msg: string) => void;\n    connect_forbidden: (msg: string) => void;\n    connect_serverError: (msg: string) => void;\n    reconnect_failed: () => void;\n}\n\nexport class GlovesLinkClient<InputEvents extends EventMap = {}, OutputEvents extends EventMap = {}> {\n    _ws: WebSocket;\n    _ackIdCounter: number;\n    _ackCallbacks: Map<number, Function>;\n    _handlers = new VEE<InputEvents>();\n    _manuallyDisconnected: boolean = false;\n    _messageQueue: string[] = [];\n    _reconnectAttempts: number = 0;\n\n    opts: GLC_Opts;\n    url: URL;\n    connected: boolean = false;\n\n    constructor(url: string, opts: Partial<GLC_Opts> = {}) {\n        this._ackIdCounter = 1;\n        this._ackCallbacks = new Map();\n        this.opts = {\n            logs: false,\n            token: null,\n            autoConnect: true,\n            statusPath: \"/gloves-link/status\",\n            reConnect: true,\n            reConnectInterval: 1000,\n            maxReConnectAttempts: 5,\n            reConnectBackoffFactor: 2,\n            maxReConnectDelay: 15_000,\n            ...opts\n        }\n\n        this.url = new URL(url, typeof window !== \"undefined\" ? window.location.href.replace(\"http\", \"ws\") : \"ws://localhost\");\n        if (this.opts.token) this.url.searchParams.set(\"token\", this.opts.token);\n\n        if (this.opts.autoConnect) this.connect();\n    }\n\n    connect() {\n        this._manuallyDisconnected = false;\n        const id = Date.now().toString(36) + Math.random().toString(36).substring(2, 10);\n        this.url.searchParams.set(\"id\", id);\n\n        if (this.opts.connectionData)\n            this.url.searchParams.set(\"data\", JSON.stringify(this.opts.connectionData));\n\n        this._ws = new WebSocket(this.url.href);\n\n        this._ws.onopen = () => {\n            this.connected = true;\n            this._reconnectAttempts = 0;\n            if (this.opts.logs) console.log(\"[ws] Connected\");\n\n            let msg: string;\n            while (msg = this._messageQueue.shift()) {\n                this._ws.send(msg);\n            }\n\n            this._handlersEmit(\"connect\");\n        }\n\n        this._ws.onerror = (...err: any) => {\n            if (this.opts.logs) console.warn(\"[ws] Error:\", err);\n            this._handlersEmit(\"error\", ...err);\n        }\n\n        this._ws.onmessage = (_data) => {\n            const raw = _data?.data?.toString() || _data?.toString() || \"\";\n            let msg: GLC_DataEvent | GLC_AckEvent;\n\n            try {\n                msg = JSON.parse(raw);\n            } catch {\n                if (this.opts.logs) console.warn(\"[ws] Invalid JSON:\", raw);\n                return;\n            }\n\n            if (\"ack\" in msg) {\n                const ackId = msg.ack;\n                const ackCallback = this._ackCallbacks.get(ackId);\n                if (ackCallback) {\n                    this._ackCallbacks.delete(ackId);\n                    ackCallback(...msg.data);\n                }\n                return;\n            }\n\n            const { evt, data, ackI } = msg;\n            if (!evt || (data && !Array.isArray(data))) return;\n\n            if (Array.isArray(ackI)) {\n                for (let i = 0; i < ackI.length; i++) {\n                    const ackIndex = ackI[i];\n                    if (!data[ackIndex]) break;\n\n                    const ackId = data[ackIndex];\n                    data[ackIndex] = (...res: any) => {\n                        this._ws.send(JSON.stringify({\n                            ack: ackId,\n                            data: res\n                        }));\n                    };\n                }\n            }\n\n            this._handlersEmit(evt, ...data);\n        }\n\n        this._ws.onclose = async (event: CloseEvent) => {\n            this.connected = false;\n            if (this.opts.logs) console.log(\"[ws] Disconnected\", event);\n            this._handlersEmit(\"disconnect\", event);\n\n            if (this._manuallyDisconnected || !this.opts.reConnect) return;\n\n            if (event.code === 1006) {\n                if (this.opts.logs) console.log(\"[ws] Connection closed by server\");\n\n                try {\n                    const canReconnect = await checkStatus(this, id);\n                    if (!canReconnect) return;\n                } catch (e) {\n                    if (this.opts.logs)\n                        console.error(\"[ws] Status error\", e);\n                }\n            }\n\n            this._reconnectAttempts++;\n\n            if (this._reconnectAttempts > this.opts.maxReConnectAttempts) {\n                if (this.opts.logs)\n                    console.error(`[ws] Max reconnect attempts reached (${this.opts.maxReConnectAttempts})`);\n\n                this._handlersEmit(\"reconnect_failed\");\n                return;\n            }\n\n            const expDelay = Math.min(\n                this.opts.reConnectInterval * this.opts.reConnectBackoffFactor ** (this._reconnectAttempts - 1),\n                this.opts.maxReConnectDelay\n            );\n\n            const jitter = 1 + Math.random() * 0.5;\n            const delay = Math.max(\n                expDelay * jitter,\n                this.opts.reConnectInterval\n            );\n\n            if (this.opts.logs)\n                console.log(\n                    `[ws] Reconnecting in ${delay.toFixed(0)}ms (attempt ${this._reconnectAttempts})`\n                );\n\n            setTimeout(() => {\n                this.connect();\n            }, delay);\n        }\n    }\n\n    on<K extends EventName<InputEvents & InternalEvents>>(event: K, listener: (InputEvents & InternalEvents)[K]) {\n        this._handlers.on(event, listener as any);\n    }\n\n    once<K extends EventName<InputEvents & InternalEvents>>(event: K, listener: (InputEvents & InternalEvents)[K]) {\n        this._handlers.once(event, listener as any);\n    }\n\n    emit<K extends EventName<OutputEvents>>(evt: K, ...args: EventArgs<OutputEvents, K>) {\n        const ackI = args.map((data, i) => {\n            if (typeof data === \"function\") return i;\n        }).filter(i => i !== undefined);\n\n        for (let i = 0; i < ackI.length; i++) {\n            const ackIndex = ackI[i];\n            const ackId = this._ackIdCounter++;\n            this._ackCallbacks.set(ackId, args[ackIndex]);\n            args[ackIndex] = ackId;\n        }\n\n        const payload = JSON.stringify({\n            evt,\n            data: args || undefined,\n            ackI: ackI.length ? ackI : undefined\n        });\n\n        if (this.connected && this._ws?.readyState === WebSocket.OPEN)\n            this._ws.send(payload);\n        else\n            this._messageQueue.push(payload);\n    }\n\n    send<K extends EventName<OutputEvents>>(evt: K, ...args: EventArgs<OutputEvents, K>) {\n        return this.emit(evt, ...args);\n    }\n\n    disconnect() {\n        this._manuallyDisconnected = true;\n        this._ws.close();\n    }\n\n    close() {\n        this._ws.close();\n    }\n\n    _handlersEmit(evtName: string, ...args: any[]) {\n        // @ts-ignore\n        this._handlers.emit(evtName, ...args);\n        // @ts-ignore\n        this._handlers.emit(\"*\", evtName, ...args);\n    }\n}\n\nasync function checkStatus(client: GlovesLinkClient, id: string) {\n    const statusURL = new URL(client.opts.statusPath, client.url.origin);\n    statusURL.searchParams.set(\"id\", id);\n    statusURL.searchParams.set(\"path\", client.url.pathname);\n\n    const statusUrl = statusURL.toString().replace(\"ws\", \"http\");\n\n    const res = await fetch(statusUrl);\n    if (!res.ok) {\n        console.error(\"[ws] Status error\", res.status);\n        return true;\n    }\n\n    const data = await res.json();\n    if (data.err) {\n        if (client.opts.logs) console.log(\"[ws] Status error\", data.msg);\n        return true;\n    }\n\n    const status = data.status as { status: number, msg?: string };\n    if (client.opts.logs) console.log(\"[ws] Status\", status);\n\n    if (status.status === 401) {\n        client._handlersEmit(\"connect_unauthorized\", status.msg);\n        return false;\n    }\n    else if (status.status === 403) {\n        client._handlersEmit(\"connect_forbidden\", status.msg);\n        return false;\n    }\n    else if (status.status === 500) {\n        client._handlersEmit(\"connect_serverError\", status.msg);\n        return false;\n    }\n\n    return true;\n}\n\nexport {\n    GlovesLinkClient as default,\n    GlovesLinkClient as GLC,\n    GlovesLinkClient as client,\n}"],
  "mappings": "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",
  "names": ["VEE", "event", "listener", "_event", "onceListener", "args", "l", "listeners", "dist_default", "GlovesLinkClient", "dist_default", "url", "opts", "id", "msg", "err", "_data", "raw", "ackId", "ackCallback", "evt", "data", "ackI", "i", "ackIndex", "res", "event", "checkStatus", "e", "expDelay", "jitter", "delay", "listener", "args", "payload", "evtName", "client", "statusURL", "statusUrl", "status"]
}
