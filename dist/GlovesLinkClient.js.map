{
  "version": 3,
  "sources": ["../node_modules/@wxn0brp/event-emitter/dist/index.js", "../src/index.ts"],
  "sourcesContent": ["export class VEE {\n    _events = {};\n    /**\n     * Registers an event listener\n     * @param {K} event - event name\n     * @param {Function} listener - function to be called when event occurs\n     */\n    on(event, listener) {\n        const _event = event;\n        if (!this._events[_event])\n            this._events[_event] = [];\n        this._events[_event].push(listener);\n    }\n    /**\n     * Registers a one-time event listener\n     * @param {K} event - event name\n     * @param {Function} listener - function to be called once\n     */\n    once(event, listener) {\n        const onceListener = (...args) => {\n            this.off(event, onceListener);\n            listener(...args);\n        };\n        this.on(event, onceListener);\n    }\n    /**\n     * Removes an event listener.\n     * @param {K} event - event name\n     * @param {Function} listener - listener to remove\n     */\n    off(event, listener) {\n        const _event = event;\n        if (!this._events[_event])\n            return;\n        this._events[_event] = this._events[_event].filter(l => l !== listener);\n    }\n    /**\n     * Emits an event\n     * @param {K} event - event name\n     * @param {...EventArgs<T, K>} args - arguments to be passed to listeners\n     */\n    emit(event, ...args) {\n        const listeners = this._events[event];\n        if (listeners && listeners.length > 0) {\n            listeners.forEach(listener => {\n                listener(...args);\n            });\n        }\n    }\n    /**\n     * Returns the number of listeners for the given event\n     * @param {K} event - event name\n     */\n    listenerCount(event) {\n        return this._events[event]?.length || 0;\n    }\n}\nexport default VEE;\nexport { VEE as EventEmitter };\n", "import VEE, { EventArgs, EventMap, EventName } from \"@wxn0brp/event-emitter\";\n\nexport interface GLC_Opts {\n    reConnect: boolean,\n    reConnectInterval: number,\n    logs: boolean;\n    token: string;\n    autoConnect: boolean;\n    connectionData?: Record<string, any>;\n}\n\nexport interface GLC_DataEvent {\n    evt: string;\n    data: any[];\n    ackI?: number[];\n}\n\nexport interface GLC_AckEvent {\n    ack: number;\n    data: any[];\n}\n\nexport type InternalEvents = {\n    connect: (ws: WebSocket) => void;\n    error: (...err: any[]) => void;\n    disconnect: (event: CloseEvent) => void;\n    connect_unauthorized: (msg: string) => void;\n    connect_forbidden: (msg: string) => void;\n    connect_serverError: (msg: string) => void;\n}\n\nexport class GlovesLinkClient<InputEvents extends EventMap = {}, OutputEvents extends EventMap = {}> {\n    public ws: WebSocket;\n    public ackIdCounter: number;\n    public ackCallbacks: Map<number, Function>;\n    public handlers = new VEE<InputEvents>();\n    public opts: GLC_Opts;\n    public url: URL;\n    public connected: boolean = false;\n    private _manuallyDisconnected: boolean = false;\n    private messageQueue: string[] = [];\n\n    constructor(url: string, opts: Partial<GLC_Opts> = {}) {\n        this.ackIdCounter = 1;\n        this.ackCallbacks = new Map();\n        this.opts = {\n            logs: false,\n            reConnect: true,\n            reConnectInterval: 1000,\n            token: null,\n            autoConnect: true,\n            ...opts\n        }\n\n        this.url = new URL(url, typeof window !== \"undefined\" ? window.location.href.replace(\"http\", \"ws\") : \"ws://localhost\");\n        if (this.opts.token) this.url.searchParams.set(\"token\", this.opts.token);\n\n        if (this.opts.autoConnect) this.connect();\n    }\n\n    connect() {\n        this._manuallyDisconnected = false;\n        const id = Date.now().toString(36) + Math.random().toString(36).substring(2, 10);\n        this.url.searchParams.set(\"id\", id);\n\n        if (this.opts.connectionData)\n            this.url.searchParams.set(\"data\", JSON.stringify(this.opts.connectionData));\n\n        this.ws = new WebSocket(this.url.href);\n\n        this.ws.onopen = () => {\n            this.connected = true;\n            if (this.opts.logs) console.log(\"[ws] Connected\");\n\n            let msg: string;\n            while (msg = this.messageQueue.shift()) {\n                this.ws.send(msg);\n            }\n\n            this._handlersEmit(\"connect\");\n        }\n\n        this.ws.onerror = (...err: any) => {\n            if (this.opts.logs) console.warn(\"[ws] Error:\", err);\n            this._handlersEmit(\"error\", ...err);\n        }\n\n        this.ws.onmessage = (_data) => {\n            const raw = _data?.data?.toString() || _data?.toString() || \"\";\n            let msg: GLC_DataEvent | GLC_AckEvent;\n\n            try {\n                msg = JSON.parse(raw);\n            } catch {\n                if (this.opts.logs) console.warn(\"[ws] Invalid JSON:\", raw);\n                return;\n            }\n\n            if (\"ack\" in msg) {\n                const ackId = msg.ack;\n                const ackCallback = this.ackCallbacks.get(ackId);\n                if (ackCallback) {\n                    this.ackCallbacks.delete(ackId);\n                    ackCallback(...msg.data);\n                }\n                return;\n            }\n\n            const { evt, data, ackI } = msg;\n            if (!evt || (data && !Array.isArray(data))) return;\n\n            if (Array.isArray(ackI)) {\n                for (let i = 0; i < ackI.length; i++) {\n                    const ackIndex = ackI[i];\n                    if (!data[ackIndex]) break;\n\n                    const ackId = data[ackIndex];\n                    data[ackIndex] = (...res: any) => {\n                        this.ws.send(JSON.stringify({\n                            ack: ackId,\n                            data: res\n                        }));\n                    };\n                }\n            }\n\n            this._handlersEmit(evt, ...data);\n        }\n\n        this.ws.onclose = async (event: CloseEvent) => {\n            this.connected = false;\n            if (this.opts.logs) console.log(\"[ws] Disconnected\", event);\n            this._handlersEmit(\"disconnect\", event);\n\n            if (this._manuallyDisconnected) {\n                this._manuallyDisconnected = false;\n                return;\n            }\n\n            if (event.code === 1006) {\n                if (this.opts.logs) console.log(\"[ws] Connection closed by server\");\n\n                const params = new URLSearchParams();\n                params.set(\"id\", id);\n                params.set(\"path\", this.url.pathname);\n\n                const statusUrl = this.url.origin + \"/gloves-link/status?\" + params.toString();\n                const res = await fetch(statusUrl.replace(\"ws\", \"http\"));\n                if (!res.ok) return console.error(\"[ws] Status error\", res.status);\n\n                const data = await res.json();\n                if (data.err) {\n                    if (this.opts.logs) console.log(\"[ws] Status error\", data.msg);\n                    return;\n                }\n\n                const status = data.status as { status: number, msg?: string };\n                if (this.opts.logs) console.log(\"[ws] Status\", status);\n                if (status.status === 401) this._handlersEmit(\"connect_unauthorized\", status.msg);\n                else if (status.status === 403) this._handlersEmit(\"connect_forbidden\", status.msg);\n                else if (status.status === 500) this._handlersEmit(\"connect_serverError\", status.msg);\n\n                return;\n            }\n            if (!this.opts.reConnect) return;\n\n            setTimeout(() => {\n                this.connect();\n            }, this.opts.reConnectInterval);\n        }\n    }\n\n    on<K extends EventName<InputEvents & InternalEvents>>(event: K, listener: (InputEvents & InternalEvents)[K]) {\n        this.handlers.on(event, listener as any);\n    }\n\n    once<K extends EventName<InputEvents & InternalEvents>>(event: K, listener: (InputEvents & InternalEvents)[K]) {\n        this.handlers.once(event, listener as any);\n    }\n\n    emit<K extends EventName<OutputEvents>>(evt: K, ...args: EventArgs<OutputEvents, K>) {\n        const ackI = args.map((data, i) => {\n            if (typeof data === \"function\") return i;\n        }).filter(i => i !== undefined);\n\n        for (let i = 0; i < ackI.length; i++) {\n            const ackIndex = ackI[i];\n            const ackId = this.ackIdCounter++;\n            this.ackCallbacks.set(ackId, args[ackIndex]);\n            args[ackIndex] = ackId;\n        }\n\n        const payload = JSON.stringify({\n            evt,\n            data: args || undefined,\n            ackI: ackI.length ? ackI : undefined\n        });\n\n        if (this.connected && this.ws?.readyState === WebSocket.OPEN)\n            this.ws.send(payload);\n        else\n            this.messageQueue.push(payload);\n    }\n\n    send<K extends EventName<OutputEvents>>(evt: K, ...args: EventArgs<OutputEvents, K>) {\n        return this.emit(evt, ...args);\n    }\n\n    disconnect() {\n        this._manuallyDisconnected = true;\n        this.ws.close();\n    }\n\n    close() {\n        this.ws.close();\n    }\n\n    _handlersEmit(evtName: string, ...args: any[]) {\n        // @ts-ignore\n        this.handlers.emit(evtName, ...args);\n        // @ts-ignore\n        this.handlers.emit(\"*\", evtName, ...args);\n    }\n}\n\nexport {\n    GlovesLinkClient as default,\n    GlovesLinkClient as GLC,\n    GlovesLinkClient as client,\n}"],
  "mappings": "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",
  "names": ["VEE", "event", "listener", "_event", "onceListener", "args", "l", "listeners", "dist_default", "GlovesLinkClient", "dist_default", "url", "opts", "id", "msg", "err", "_data", "raw", "ackId", "ackCallback", "evt", "data", "ackI", "i", "ackIndex", "res", "event", "params", "statusUrl", "status", "listener", "args", "payload", "evtName"]
}
